import { NextRequest, NextResponse } from 'next/server'
import { getAuthUser } from '@/lib/middleware'
import pool from '@/lib/db'
import Replicate from 'replicate'

export async function POST(request: NextRequest) {
  try {
    const { prompt, settings } = await request.json()

    console.log('üé® Replicate Image Generation Request:', { 
      prompt: prompt?.substring(0, 50), 
      settings 
    })

    // Get authenticated user first
    const user = await getAuthUser(request)
    
    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    if (!prompt) {
      return NextResponse.json(
        { error: 'Prompt is required' },
        { status: 400 }
      )
    }

    // Check if API key exists
    const apiKey = process.env.REPLICATE_API_KEY
    if (!apiKey) {
      console.error('‚ùå Replicate API key not configured')
      return NextResponse.json(
        { error: 'Replicate API key not configured' },
        { status: 500 }
      )
    }

    // Deduct credits - Replicate costs 2 credits
    const client = await pool.connect()
    
    try {
      await client.query('BEGIN')

      // Get current credits
      const creditsResult = await client.query(
        'SELECT * FROM credits WHERE user_id = $1 FOR UPDATE',
        [user.id]
      )

      if (creditsResult.rows.length === 0) {
        throw new Error('User credits not found')
      }

      const currentCredits = creditsResult.rows[0]
      const requiredCredits = 2

      // Check if user has enough credits
      if (currentCredits.remaining_credits < requiredCredits) {
        await client.query('ROLLBACK')
        return NextResponse.json(
          { 
            error: `Insufficient credits. You need ${requiredCredits} credits for image generation.`,
            remaining: currentCredits.remaining_credits,
            required: requiredCredits
          },
          { status: 400 }
        )
      }

      // Deduct credits
      const newUsedCredits = currentCredits.used_credits + requiredCredits
      const newRemainingCredits = currentCredits.total_credits - newUsedCredits

      await client.query(
        `UPDATE credits 
         SET used_credits = $1, remaining_credits = $2
         WHERE user_id = $3`,
        [newUsedCredits, newRemainingCredits, user.id]
      )

      // Record transaction
      await client.query(
        `INSERT INTO credit_transactions 
         (user_id, action_type, credits_used, model_used, description)
         VALUES ($1, $2, $3, $4, $5)`,
        [user.id, 'image_generation', requiredCredits, 'gemini-2.0-flash', `Image generation: ${prompt.substring(0, 50)}...`]
      )

      await client.query('COMMIT')
      
      console.log('üí≥ Credits deducted successfully:', {
        remaining: newRemainingCredits,
        used: requiredCredits
      })
      
    } catch (error: any) {
      await client.query('ROLLBACK')
      client.release()
      throw error
    } finally {
      client.release()
    }

    // Initialize Gemini client instead of Replicate
    const { GoogleGenAI, Modality } = await import('@google/genai')
    const geminiApiKey = process.env.GEMINI_IMAGE_API_KEY || process.env.VEO_API_KEY || process.env.GEMINI_API_KEY
    
    if (!geminiApiKey) {
      throw new Error('Gemini API key not configured')
    }
    
    const gemini = new GoogleGenAI({ apiKey: geminiApiKey })

    console.log('üé¨ Calling Gemini API for image generation...')
    console.log('Prompt:', prompt.substring(0, 100))

    // Use Gemini 2.0 Flash Experimental with image generation
    const response = await gemini.models.generateContent({
      model: 'gemini-2.0-flash-exp',
      contents: [{
        role: 'user',
        parts: [{ text: `Generate a high-quality image: ${prompt}` }]
      }],
      config: {
        responseModalities: [Modality.IMAGE],
      }
    })

    // Extract image from response
    const parts = response.candidates?.[0]?.content?.parts || []
    let imageData = ''
    
    for (const part of parts) {
      if (part.inlineData) {
        imageData = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`
        break
      }
    }

    if (!imageData) {
      throw new Error('No image generated by Gemini')
    }

    console.log('‚úÖ Image generated successfully with Gemini')

    return NextResponse.json({
      success: true,
      prompt: prompt,
      enhancedPrompt: prompt,
      imageData: imageData,
      settings: settings,
      model: 'gemini-2.0-flash',
      timestamp: new Date().toISOString()
    })

  } catch (error: any) {
    console.error('Gemini Image Generation Error:', error)
    console.error('Error details:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    })
    
    return NextResponse.json(
      { 
        error: 'Failed to generate image', 
        message: error.message || 'Unknown error occurred',
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      },
      { status: 500 }
    )
  }
}
